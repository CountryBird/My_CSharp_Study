`LINQ`, `Language-Integrate Query`는 C# 언어 자체에 쿼리 기능이 통합된 개념입니다.     

기존의 쿼리 방식의 문제점이었던,      
**컴파일 시점에 문제 찾기 어려움**, **데이터 소스마다의 쿼리 언어 숙지 필요** 를 해결한 형태입니다. 

쿼리가 클래스, 메서드와 같이 언어의 기본 요소로 취급되며,     
IntelliSense (코드 자동완성) 기능도 제공하기에 효율적인 코딩이 가능해집니다.  

### - 반환 형태       
메모리 내의 컬렉션에 대해서는 `IEnumerable<T>`를,     
외부 데이터베이스의 소스에 대해서는 `IQueryable<T>`를 반환합니다.   

### - 기본 예제
```cs
int[] lengths = [100, 97, 34, 66, 2];

IEnumerable<int> lengthsOver50
  = from length in lengths
    where length > 50
    select length;
```
LINQ의 가장 기본적인 형태이며, 풀어서 보면
-  `from` 아이템 `in` 컬렉션      
: _컬렉션_ 에서 _아이템_ 각각을 꺼내서 사용한다는 의미입니다.      
: _컬렉션_ 은 기존에 존재하는 객체이어야 하고, _아이템_ 은 LINQ 내부에서 선언하여 사용합니다.

- `where` 조건           
: 일종의 필터 역할을 하며, 조건에 대해 `true`인 아이템만 선택됩니다.      
: 조건식은 C# 문법 그대로 사용할 수 있습니다.

- `select` 결과값       
: 어떤 값을 결과로 내보낼지 지정합니다.       
: 반드시 모든 객체를 내보낼 필요는 없으며, 일부만 내보내도 무방합니다.

# 쿼리 식 개요
- 쿼리 표현식은, LINQ가 지원하는 데이터 형식이면 얼마든지 쿼리하고 변환될 수 있습니다.     
단적인 예로, 단일 쿼리가 DB로부터 데이터를 가져와 XML 형태로 반환하는 것도 가능합니다.

- 쿼리 표현이 C#과 매우 친숙한 형태이기 때문에, 쉽게 읽고 쓸 수 있습니다.

- 변수가 모두 강한 타입이기 때문에, 타입 안정성이 높고 코드 자동 완성 등의 기능을 사용하기 좋습니다.

- `foreach` 같은 순회를 통한 실제 데이터 사용 전까지는 실행되지 않습니다. (선언과 동시에 실행이 아님)

- 컴파일 시간에 내부적으로 쿼리문은 메서드 호출 형태로 변환됩니다.
```cs
var lengthsOver50
  = from length in lengths
    where length > 50
    select length;
```
위와 같은 쿼리문이
```cs
var lengthOver50 = lengths.Where(length => length >50).Select(length => length);
```
내부적으로는 이와 같은 형태로 변환되어 실행됩니다. 

- 쿼리문 형태와 메서드 호출 형태의 성능적인 차이가 없으며 서로 변환이 가능합니다.       
단, Count나 Max와 같은 특정 메서드 작업은 메서드 호출로만 표현 가능합니다. (해당하는 쿼리 절이 없음)

- `IEnumerable` 형태는 대리자로, `IQueryable` 형태는 식 트리로 컴파일됩니다.      
`IEnumerable`을 사용하는 **메모리 컬렉션**은 _단순히 식을 실행함_ 으로써 값이 정상적으로 나오지만,       
`IQueryable`을 사용하는 **외부 데이터베이스 소스**는 _추가적인 DB 문법으로의 변환_ 을 거쳐야     
정상적으로 값을 가져올 수 있기 때문에 구조를 파악하기 위해 식 트리 방법을 사용합니다.

# 데이터 소스에 대한 LINQ 쿼리 활성화 방법
## In-memory 데이터
메모리 내의 데이터를 사용해 LINQ 쿼리를 사용하는 법은 크게 2가지가 있습니다.    

- IEnumerable<T>를 구현하는 타입
: List와 같은 `IEnumerable<T>`를 구현하는 타입이라면, 바로 LINQ to Objects를 사용할 수 있습니다.        
즉, 따로 처리할 것 없이 LINQ 문법을 사용 가능하다는 의미입니다.

- IEnumerable<T>를 구현하지 않는 타입
: 표준 쿼리 연산자 메서드를 타입에 정의하거나, 확장 메서드로 구현해 주어야 합니다.       
사실상 LINQ 문법을 모사한 메서드를 따로 만들라는 의미입니다.     
## 원격 데이터
`IQueryable<T>`를 구현하는 방법을 사용할 수 있습니다.     
해당 인터페이스는 쿼리를 원격에 전달하여 처리하는 방식입니다.     

 # IQueryable LINQ 프로바이더
 : _LINQ 프로바이더_ 는 _LINQ 쿼리를 실제 데이터 소스에 맞는 명령으로 바꿔주는 번역기_ 의 개념입니다.       
 프로바이더의 복잡도 수준에 따라 특징을 나눌 수 있는데,   

 ## 간단한 수준의 IQueryable 프로바이더
 단일 웹 서비스 메서드에 접근하는 경우가 이러하며,     
 원하는 정보가 매우 구체적이며, 제한된 타입 시스템을 가집니다.      
 또한 대부분의 쿼리가 `Enumerable` 등의 구현을 통해 로컬에서 처리됩니다.     
 쿼리 표현식 트리에서 한 개의 메서드 호출만 분석합니다.     

 ## 중간 복잡도의 IQueryable 프로바이더
 일부 쿼리 표현이 가능한 웹 서비스나 데이터 소스의 경우이며,     
 여러 메서드를 호출 가능하고, 목적에 따라 선택하는 형태입니다.     
 고정된 타입 시스템을 가지고, 비교적 단순한 관계를 제공합니다.     
 사용자 정의 타입에 대한 매핑 기술은 없다고 간주됩니다.    

 ## 고급 복잡도의 IQueryable 프로바이더
 Entity Framework Core가 대표적인 예입니다.      
 전체 LINQ 쿼리를 SQL 수준의 쿼리 언어로 변환합니다.     
 개방형 타입 시스템을 지원하기에, 사용자 정의 타입 매핑이 가능합니다.     
 다양한 쿼리 처리가 가능해 범용적이지만, 개발을 위해서는 그만큼의 노력이 필요합니다. 
