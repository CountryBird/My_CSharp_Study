# 대리자란?
대리자는 개체에 대한 참조를 저장하는 방법과 비슷하게, 메서드에 대한 참조를 저장하는 방법으로 사용됩니다.    
메서드에 개체를 전달할 수 있는 것처럼 대리자를 사용하여 메서드 참조를 전달할 수 있습니다.      
이 기능을 통해 다양한 메서드를 **연결** 하여 다른 동작을 제공하는 유연한 코드를 작성할 수 있습니다.    

# 대리자 타입 정의
`delegate` 키워드를 통해 대리자 타입을 만들 수 있습니다.     

```cs
public delegate int Calculator(int x, int y);
```
이 `Calculator` 대리자는 2개의 `int` 파라미터를 받고 `int`를 반환하는    
모든 메서드에 대한 참조를 보유할 수 있습니다.    

```cs
public delegate int Comparison<in T>(T left, T right);
```
이 `Comparison`은 조금 더 실용적인 예제로,    
`T`를 통해 동적으로 2개의 파라미터의 타입을 결정할 수 있는 형태입니다.   

이와 같이 대리자 타입을 정의하면, 컴파일러는 `System.Delegate`에서 파생된 클래스를 자동으로 생성합니다.    
해당 클래스가 메서드 참조, 저장, 호출에 대한 복잡한 작업을 처리하기 때문에, 개발자는 작은 작업으로 대리자 작업을 사용할 수 있습니다.   

단순히 변수를 선언하는 수준으로만 보이지만, 실제로는 아예 새로운 타입을 선언하는 것입니다.     
컴파일러는 이 새로운 타입에 대한 추가/제거 처리기를 자체적으로 생성합니다.   


# 대리자의 인스턴스 선언
대리자 타입을 정의한 후 해당 형식의 인스턴스를 만들 수 있습니다.   
메서드에 대한 참조를 위한 **_슬롯_** 의 개념으로 생각하면 편합니다.   

C#의 모든 변수와 마찬가지로 네임스페이스 또는 전역 네임스페이스에서 직접 대리자 인스턴스를 선언할 수는 없습니다.   
```cs
public Comparison<T> comparator;
```
이 변수는, `Comparison<T>` 타입이 변수의 이름입니다.   
이전이 정의를 하는 코드였다면, 해당 코드는 실제 객체 슬롯을 만든 것이고     
아직 메서드가 지정되지 않았기 때문에 해당 상태로는 사용할 수 없습니다.    

# 대리자 호출
메서드를 가리키는 대리자 인스턴스가 있으면,   
대리자를 통해 그 메서드를 호출할 수 있습니다.    

대리자 자체를 메서드 호출하듯이 호출하여 대리자 호출 목록에 있는 메서드를 실행합니다.   

```cs
int result = comparator(left, right);
```
해당 코드는 대리자에 연결된 메서드를 호출할 수 있습니다.    

단, 이 코드 줄은 안전하지 않을 수 있습니다.    
메서드가 연결되지 않은 경우 `NullReferenceExcption`가 발생할 수 있습니다.   

# 호출 대상 할당, 추가 및 제거
대리자를 사용하기 위해서는 메서드를 할당해야 합니다.      
할당하는 메서드는 정의된 대리자와 같은 타입을 사용해야 합니다.   

```cs
private static int CompareLength(string left, string right)
=> left.Length.CompareTo(right.Length);
```
위와 같은 형식으로 메서드를 정의할 수 있습니다.      
이는 다른 메서드 선언과 크게 다를 바가 없으며, 실제로 정적 메서드를 선언하는 코드입니다.   

```cs
phrases.Sort(CompareLength);
```
선언된 메서드에 대해 괄호를 사용하지 않는 방법을 통해
**메서드를 참조하여 사용할 수 있습니다.**       
이는 해당 메서드를 델리게이트로 받아 사용함을 의미합니다.    

```cs
Comparison<string> comparer = CompareLength;
phrases.Sort(comparer);
```
위의 코드를 통해서도 델리게이트로 사용할 수 있습니다.    
이전의 코드와 비교하였을 때, 덜 간결하지만 명확하게 델리게이트를 선언할 수 있습니다.

```cs
Comparison<string> comparer = (left, right) => left.Length.CompareTo(right.Length);
phrases.Sort(comparer);
```
코드가 복잡하지 않은 경우 람다 식을 사용해 대리자를 사용할 수 있습니다.    

# Delegate 및 MulticastDelegate 클래스
대리자 기능은 .NET Framework의 `Delegate`와 `MulticastDelegate`의 두 클래스를 기반으로 빌드됩니다.      
이러한 클래스를 직접적으로 다루지는 않고, 기반으로 사용됩니다.    

`System.Delegate`와 `System.MulticastDelegate`는 직접적으로 사용되는 대리자 타입은 아니고,    
C# 언어 중에서 `delegate`를 사용하여 상속받아 사용할 수 있습니다.   

`delegate` 키워드를 사용하여 대리자 타입을 선언하면,      
C# 컴파일러는 자동으로 `MulticastDelegate`에서 클래스를 파생하여 사용합니다.      

## 왜 이 디자인인가요?
다음과 같은 목표를 위해 이러한 디자인을 가집니다.    

1. 타입 안전: 대리자가 올바른 형식과 인수 수를 사용하여 호출되고 반환되도록, 컴파일 시간에 확인할 수 있기 위함입니다.   
2. 성능: 컴파일러가 특정 메서드를 나타내는 구체적인 대리자 클래스를 생성하게 함으로써 런타임에 대리자 호출을 최적화할 수 있습니다.
3. 단순성: 제네릭이 도입되기 전인 1.0 .NET 릴리즈에 대리자가 포함되어고, 이는 시간 제약 조건 내의 작동을 위한 디자인입니다.

## 대리자 메서드를 사용한 작업
 `Delegate`와 `MulticastDelegate`의 파생 클래스를 직접 만들 수는 없지만,     
 때때로 해당 클래스에서 정의된 메서드를 사용하기 때문에 알아 두어야 할 필요성이 있습니다.    

 모든 대리자는 `MulticastDelegate`에서 파생됩니다.    
 이는 대리자를 통해 호출할 때 둘 이상의 메서드 대상을 호출할 수 있음을 의미합니다.    

 원래 디자인에서는 _하나의 메서드만 호출할 수 있는 대리자_ 와 _여러 메서드를 호출할 수 있는 대리자_ 를 구분하는 것을 고려했습니다.    
 하지만 이런 구분은 생각보다 덜 유용하였고, 결국 현재 `delegate`는 `MulticastDelegate`를 상속받는 형태로 통일되었습니다.      

 대리자를 사용할 때 일반적으로 사용되는 메서드는 다음과 같습니다.   
 - `Invoke()`: 대리자에 연결된 모든 메서드를 호출합니다.
 - `BeginInvoke()` / `EndInvoke()`: 비동기 호출 패턴에 사용됩니다.
