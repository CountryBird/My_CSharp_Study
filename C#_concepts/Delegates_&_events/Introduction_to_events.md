이벤트는 대리자 처럼 _지연 바인딩_ 메커니즘입니다.       
실제로 이벤트는 대리자 언어 지원을 기반으로 합니다.        

이벤트는 개체가 어떤 일이 발생했는지 브로드캐스트하는 방법입니다.       
다른 모든 구성 요소는 이벤트를 구독할 수 있으며 이벤트가 알림을 받을 수 있습니다.        

많은 그래픽 시스템에는 이러한 이벤트 모델이 있는데,         
마우스 이동, 단추 누르기 등 유사한 상호 작용을 보고합니다.     

클래스에 대해 발생해야 하는 이벤트를 정의할 수 있습니다.         
이벤트로 작업할 때 고려해야 할 사항은, 특정 이벤트에 대해 등록된 개체가 없을 수도 있다는 것입니다.      

또한 이벤트를 구독하면 이벤트 원본과 싱크간의 결합이 만들어집니다.        
때문에 이벤트를 사용하지 않으면 이벤트 수신기가 이벤트 소스에서 구독을 취소해야 합니다.          

# 이벤트 지원을 위한 디자인 목표
이벤트에 대한 언어 디자인은 다음 목표를 대상으로 합니다.      

- 이벤트 원본과 이벤트 싱크 간의 최소 결합을 사용하도록 설정합니다.       
이러한 두 구성 요소는 서로 다른 조직에서 작성할 수 있으며 다른 일정에 따라 업데이트될 수도 있습니다.      
- 이벤트를 구독하고 동일한 이벤트에서 구독을 취소하는 것은 간단해야 합니다.
- 이벤트 원본은 여러 이벤트 구독자를 지원해야 합니다.
또한 이벤트 구독자가 연결되지 않은 경우도 지원해야 합니다.

# 이벤트에 대한 언어 지원
이벤트를 정의하고 이벤트ㅔ서 구독 또는 구독 취소하는 구문은 대리자 구문의 확장 형태입니다.      
`event` 키워드를 통해 이벤트를 정의합니다.     

```cs
public event EventHandler<FileFoundArgs>? FileFound;
```
해당 예제에서 `EventHandler<FileListArgs>` 타입은 대리자 타입이어야 합니다.      
전형적으로 이벤트 대리자 유형은 void를 반환하며 선언을 과거 시제의 동사 구문을 통해 합니다.     
또한 종종 계속적으로 사용되는 유형도 있는데, 이 때는 ~ing 구문을 사용합니다.     

이벤트를 발생시키려는 경우, `Invoke`문을 사용할 수 있습니다.      
```cs
FileFound?.Invoke(this, new FileFoundArgs(file));
```
`?.` 연산자를 사용하면, 해당 이벤트에 대한 구독자가 있을 때는 정상 실행,       
그렇지 않을 때는 발생시키지 않도록 할 수 있습니다.      

```cs
var fileLister = new FileSearcher();
int filesFound = 0;

EventHandler<FileFoundArgs> onFileFound = (sender, eventArgs) =>
{
    Console.WriteLine(eventArgs.FoundFile);
    filesFound++;
};

fileLister.FileFound += onFileFound;
```
`+=` 연산자를 사용하여 이벤트를 구독할 수 있습니다.     
